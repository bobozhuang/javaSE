选择排序和冒泡排序的对比
    冒泡：
    for (int i = 0; i < array.length; i++) {
        for (int j = 0; j < array.length - i - 1; j++) {
            if (array[j] > array[j + 1]) {
                exch(array, j, j + 1);
            }
        }
    }
        大for循环从第一个元素开始经过一轮小for循环最大的值已经是最后一个元素
        大for循环从第一个元素开始经过一轮小for循环第二大的值已经是倒数第二个元素了，但是选择冒泡没有将倒数第一和第二进行
        了比较因为我们可以确定第一轮最大的值已经交换到了最后一个
    选择：
    for (int i = 0; i < arr.length; i++) {
        for (int j = 0; j < arr.length - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                exch(arr, j, j + 1);
            }
        }
    }
        大for循环从第一个元素开始经过一轮小for循环最大的值已经是最后一个元素
        大for循环从第一个元素开始经过一轮小for循环第二大的值已经是倒数第二个元素了，但是选择排序还是将倒数第一和第二进行
        了比较
    选择优化之后:（）
    for (int i = 0; i < arr.length; i++) {
        int k = i;// 找出最小值的下标
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[k] > arr[j]) {
                k = j;
            }
        }// 将最小值放到未排序记录的第一个位置
        if (k > i) {
            exch(arr, i, k);
        }
    }
    冒泡：比较次数为: N * (N - 1)/ 2, 移动次数：N * (N - 1)/ 2  (可以看出选择和冒泡每次小for循环执行结果一样)
    876543219
    765432189
    654321789
    543216789
    432156789
    321456789
    213456789
    123456789
    123456789
    选择：比较次数为 N * (N - 1), 移动次数：N * (N - 1)/ 2（但实际是不一样的，冒泡在每次小for循环执行时都比上一次少比较一次，因为
    每次小for循环执行结束最大的值就是最后一个元素了，所以冒泡下次小for循环已经确定的最大值就不参与比较了）
    876543219
    765432189
    654321789
    543216789
    432156789
    321456789
    213456789
    123456789
    123456789
    选择优化：比较次数为 N * (N - 1) / 2, 移动次数： N / 2
    187654329
    127654389
    123654789
    123456789
    123456789
    123456789
    123456789
    123456789
    123456789

    876543219
    765432189
    654321789
    543216789
    432156789
    321456789
    213456789
    123456789
