 希尔排序
    希尔排序的算法思想：将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次将gap折半
    减小，循环上述操作；当gap=1时，利用直接插入，完成排序。

    希尔排序是对插入排序的一种改进，它的核心思想是将待排序数组中任意间隔为h的元素都变为有序的，这样的数组叫做h有序数组。
    比如数组[5, 3, 2, 8, 6, 4, 7, 9, 5],
    我们可以看到a[0]、a[3]、a[6]是有序的，a[1]、a[4]、a[7]是有序的，a[2]、a[5]、a[8]是有序的，
    因此这个数组是一个h有序数组（h=3）。
    根据h有序数组的定义，我们可以知道，当h=1时，相应的h有序数组就是一个已经排序完毕的数组了。

    希尔排序的大致过程如下：
        把待排序数组分割为若干子序列（一个子序列中的元素在原数组中间隔为h，即中间隔了h-1个元素），然后对每个子序列分别
        进行插入排序。然后再逐渐减小h，重复以上过程，直至h变为足够小时，再对整体进行一次插入排序。由于h足够小时，待排
        序数组的逆序数已经很小，所以再进行一次希尔排序是很快的。希尔排序通常要比插入排序更加高效。

    实现希尔排序时，我们需要选取一个h的取值序列，这里我们直接采用算法（第4版） (豆瓣)一书中提供的
        h取值序列（1,4,13,40,121, ...)。即h =  3 * k + 1，其中k为[0, N/3)区间内的整数。希尔排序的Java描述如下：

public class Shell {
    public static void sort(int[] a) {
        int N = a.length;
        int h = 1;
        while (h < N / 3) {
            h = 3 * h + 1; //h的取值序列为1, 4, 13, 40, ...
        }
        while (h >= 1) {
            int n, i ,j, k;
            //分割后，产生n个子序列
            for (n = 0; n < h; n++) {
                //分别对每个子序列进行插入排序
                for (i = n + h; i < N; i += h) {
                    for (j = i - h; j >= 0 && a[i] < a[j]; j -= h) {

                    }
                    int tmp = a[i];
                    for (k = i; k > j + h; k -= h) {
                        a[k] = a[k-h];
                    }
                    a[j+h] = tmp;
                }
            }
            h = h / 3;
        }
    }



}

    实际上，h的取值序列的选取会影响到希尔排序的性能，不过以上我们选取的h值序列在通常情况下性能与复杂的取值序列相接近，但是在最坏情况下的性能要差一些。分析希尔排序的复杂度不是一件容易的事，这里我们引用《算法》一书中关于希尔排序复杂度的结论：

使用递增序列1, 4, 13, 40, 121, 364, ...的希尔排序所需的比较次数不会超过数组尺寸的若干倍乘以递增序列的长度。

    也就是说，在通常情况下，希尔排序的复杂度要比O(n^2)好得多。实际上，最坏情况下希尔排序所需要的比较次数与O(n^1.5)成正比，在实际使用中，希尔排序要比插入排序和选择排序、冒泡排序快得多。而且尽管待排序数组很大，希尔排序也不会比快速排序等高级算法慢很多。因此当需要解决排序问题而用没有现成系统排序函数可用时，可以优先考虑希尔排序，当希尔排序确实满足不了对性能的要求时，在考虑使用快速排序等算法。

    到这里，我们要介绍的基本排序算法就介绍完了，再介绍快速排序、归并排序、堆排序等高级排序算法前，我们先来简单地介绍下如何比较各种排序算法的实际性能，这也能够帮助我们直观的看到希尔排序相比与插入排序等的性能优势。