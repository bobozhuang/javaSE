**代理模式的应用场景：**  

	如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：  
	1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。  
	2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。  
	使用代理模式，可以将功能划分的更加清晰，有助于后期维护！  


**注意:**  装饰模式和代理模式在很多情况下,大部分代码都是类似的，但是这俩种设计的意图是不一样的,装饰模式是增强被包装对象的
		功能,代理模式是控制被代理对象的行为 
	例如一块代码，如果被描述为使用了装饰模式,那么我们就知道设计的意图是增加被包装对象的功能,如果被描述为使用了代理模式,那
		么我们就知道设计的意图是控制被代理对象的行为，虽然这俩种情况下他们的代码结构基本相同.
		
装饰器模式：能动态的新增或组合对象的行为。
	代理模式   ：为目标对象提供一种代理以便控制对这个对象的访问.
	装饰模式是“新增行为”，而代理模式是“控制访问”。


	1.装饰模式：对被装饰的对象增加额外的行为
	如：杯子生产线，杯子必须可以装水，在生产线上可以给杯子涂颜色，加杯盖，但要保证杯子可以装水。
	2.代理模式：对被代理的对象提供访问控制。
	如：客户网上商城订购商品，网上商城是厂家的代理，网上商城可以帮客户完成订购商品的任务，但是商城可以对商品进行控制，不交
		钱不给商品，人不在不给商品，也可以赠送你额外的礼品，代金券。 

根据创建时期，代理类可分为两种：
	      静态代理类：
		    由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。
	      动态代理类：在程序运行时，运用反射机制动态创建而成。
	      	    与静态代理类对照的是动态代理类，动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它
		    的源代码。动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的
		    动态代理类。java.lang.reflect 包下面的Proxy类和InvocationHandler 接口提供了生成动态代理类的能力。
		    Proxy 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类。
		    InvocationHandler 是代理实例的调用处理程序 实现的接口。
		InvocationHandler	//调用本地处理者

    CGLib代理(第三方类库)
   	JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。
	CGLib	采用了非常底层的字节码技术，其原理是通过字节码技术为目标对象创建一个子类对象，并在子类对象中拦截所有父类方法
	的调用，然后在方法调用前后调用后都可以加入自己想要执行的代码。
   	需要这种方法只是需要俩个第三方jar包: cglib-3.2.1.jar和asm-5.0.4.jar
   	同时很多框架已经把这些jar包整合到一起了，比如spring框架的spring-core-3.2.4.RELEASE.jar,这一个jar包就包括上述俩个jar包
	的大多数功能


